\documentclass[a4paper,10pt,twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-ucroman,es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{algpseudocode}
\usepackage{enumitem} % Provee macro \setlist
\usepackage[toc, page]{appendix}

% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Deshabilita sangría en la primer línea de un párrafo.
\setlength{\parindent}{0em}

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 1 · Algoritmos y Estructuras de Datos III}
\rhead{Lovisolo · Petaccio · Rossi}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudo}[1][]{%
    \vspace{0.5em}%
    \begin{algorithmic}%
}
{%
    \end{algorithmic}%
    \vspace{0.5em}%
}

% Conectivo 'in' para usar así: \ForAll{$foo$ \In $bar$}
\newcommand{\In}{\textbf{in} }

% Complejidades
\newcommand{\Ode}[1]{\hfill $O(#1)$}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 1
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Algoritmos y Estructuras de Datos III
\end{Large}

\vspace{1cm}

Segundo Cuatrimestre de 2013

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Leandro Lovisolo      & 645/11 & leandro@leandro.me\\
Lautaro José Petaccio & 443/11 & lausuper@gmail.com\\
Lucas Rossi           & 705/11 & lucasrossi20@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}

En el presente trabajo estudiamos tres problemas algorítmicos, proponemos soluciones para los mismos respetando sus requerimientos de complejidad temporal y analizamos empíricamente los tiempos de ejecución de sus implementaciones en lenguaje C++.

La motivación de este trabajo es comparar las cotas temporales obtenidas del análisis teórico con las mediciones de tiempos de ejecución y extraer conclusiones de esta experimentación.

Sin más, presentamos los problemas estudiados a continuación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 1: Pascual y el correo                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Problema 1: Pascual y el correo}

Dada una secuencia de paquetes y un límite de peso, se nos pide calcular, la cantidad de camiones necesarios y sus pesos, para realizar el transporte de los mismos, utilizando el método del encargado de logística llamado Pascual, el cuál consiste en lo siguiente:

\begin{itemize}
\item Si un paquete excede el peso del camión cargado con menor peso, se pide un nuevo camión y se coloca el paquete.
\item Si el paquete no supera el peso del camión cargado de menor peso, se lo coloca en el camión de menor peso.
\end{itemize}

Se nos pide resolver el problema con una cota de complejidad temporal \textbf{estrictamente mejor} que $O(n^2)$.

\textbf{Ejemplo del problema y su solución:}
\begin{itemize}
	\item El formato de entrada es el siguiente: \\
  límite cantidadDePaquetes paquete1 paquete 2... \#
	\item El formato de salida es el siguiente: \\
	cantidadDeCamiones pesoCamion1 pesoCamion2 ...
\end{itemize}

\textbf{Entrada}: 100 3 80 40 60 \#.\\
\textbf{Salida}: 2 80 100. \\
El camión 1 recibe el primer paquete de 80. Al intentar luego colocar el paquete de 40 en este, no le es posible debido a que el límite es 100 y lo guarda en el camión 2, al que luego, se le suma el paquete de 60, el cuál no provoca que el límite sea superado al colocarse en este.

\subsection{Solución}

Sea $\langle p_1, \ldots, p_n \rangle$ la secuencia que contiene los pesos de los $n$ paquetes en orden de llegada, sea $\langle c_1, \ldots, c_m \rangle$ la secuencia en orden ascendente que contiene las cargas de los camiones en un determinado momento (inicialmente vacía) y sea $L$ el límite de carga de los camiones.

Para cada paquete $p_i$, cargamos el paquete en el camión menos cargado $c_1$ si la nueva carga no supera el límite $L$, o en caso contrario agregamos un nuevo camión $c_{m+1} = p_i$ a la secuencia, realizando las permutaciones necesarias para preservar el orden ascendente.

Luego de haber cargado todos los paquetes, devolvemos la secuencia con la carga de cada camión.

Para cumplir con los requerimientos de complejidad temporal, utilizamos una cola de prioridad min-heap en lugar de una secuencia para almacenar las cargas de cada camión.

\begin{pseudo}
    \Procedure{Pascual-y-el-correo}{$\langle p_1, \ldots, p_n \rangle, L$}
        \State $C \leftarrow$ nuevo min-heap                    \Ode{1}
        \ForAll{$p$ \In $\langle p_1, \ldots, p_n \rangle$}     \Ode{1}
            \If{$C.tama\tilde{n}o = 0$}                         \Ode{1}
                \State $C.encolar(p)$                           \Ode{log(n)}
            \ElsIf{$C.siguiente() + p \leq L$}                  \Ode{1}
                \State $c \leftarrow C.siguiente() + p$         \Ode{1}
                \State $C.desencolar()$                         \Ode{log(n)}
                \State $C.encolar(c)$                           \Ode{log(n)}
            \Else
                \State $C.encolar(c)$                           \Ode{log(n)}
            \EndIf
        \EndFor
        \State \textbf{return} $C$
    \EndProcedure
\end{pseudo}


\subsection{Complejidad}

El algoritmo corre en tiempo $O(n*log(n))$, donde $n$ es la cantidad de paquetes.

Demostración: para cada uno de los $n$ paquetes, se realizan 1 ó 2 operaciones $O(log(n))$ sobre la cola de prioridad. Luego deducimos la complejidad total $n * O(log(n)) = O(n * log(n))$.

\subsection{Correctitud}
Al utilizar un \textbf{min-heap} como estructura para almacenar los camiones, es posible asegurar que en su cabecera se tendrá el camión menos cargado siempre, corroborando el correcto funcionamiento de la consigna, la cuál describe que las comparaciones para elegir el destino del paquete se hacen con el camión de menor peso. 

Si la suma del peso del camión en la cabecera y el nuevo paquete no superan el límite, se procede a desencolar del heap el camión, se le carga el nuevo paquete aumentando su peso y se lo encola nuevamente en el heap el cuál se encargará de dejar el nuevo camión con menos peso en la cabecera.

Si es requerido un nuevo camión, se crea uno nuevo con el peso del paquete a colocar y se lo encola en el heap, nuevamente el heap se encargará de colocar el camión de menor peso en la cabecera.

Al asumir el correcto funcionamiento del heap, ya que para este se utiliza la STL, podemos  confirmar que las operaciones se realizan correctamente.

\subsection{Experimentos computacionales}
\subsubsection{Verificación de correctitud}
Elegimos los siguientes casos para verificar la correctitud del programa:
\begin{enumerate}
	\item Entrada vacía, verifica el comportamiento del algoritmo ante la posibilida de no recibir ningún paquete en la entrada.
	\item Entrada con un único paquete, verifica el primer caso, el de tener el \textbf{min-heap} vacío.
	\item Entrada en la cual en algún camión se deba insertar más de un paquete. Esto verifica el caso del \textbf{else if} descripto en el pseudocódigo.
	\item Entrada en la cual algún camión no pueda contener el peso del nuevo paquete y deba pedir un nuevo camión. Esto verifica el caso final (\textbf{else}), debiendo incluir un nuevo camión.
\end{enumerate}

\subsubsection{Performance}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 2: Profesores visitantes                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Problema 2: Profesores visitantes}

Dado un conjunto de $n$ cursos con una fecha de inicio y una fecha de finalización, se nos pide hallar el subconjunto con mayor cantidad de cursos tales que ningún curso se solapa con otro.

Se representa cada curso con una tupla $(i, f)$, donde $i$ y $f$ son las fechas de inicio y finalización del curso, respectivamente, tales que $i \leq f$.

Formalizamos solapamiento de la siguiente manera: dos cursos $(i_1, f_1)$ y $(i_2, f_2)$ con $f_1 \leq f_2$ se solapan si y sólo si $f_1 \geq i_2$.

Se nos pide resolver el problema con una cota de complejidad temporal \textbf{estrictamente mejor} que $O(n^2)$.

Algunas instancias del problema y sus soluciones:

\textbf{Entrada}: $\{(1, 3), (4, 4), (2, 5)\}$.\\
\textbf{Salida}: $\{(1, 3), (4, 4)\}$.

\textbf{Entrada}: $\{(1, 15), (2, 3), (3, 4), (5, 6), (7, 8), (4, 10)\}$.\\
\textbf{Salida}: $\{(2, 3), (5, 6), (7, 8)\}$ ó $\{(3, 4), (5, 6), (7, 8)\}$; cualquiera de las dos son correctas.

\textbf{Entrada}: $\{(1, 2)\}$.\\
\textbf{Salida}: $\{(1, 2)\}$.

\textbf{Entrada}: $\emptyset$.\\
\textbf{Salida}: $\emptyset$.


\subsection{Solución}

Sea $C = \langle (i_1, f_1), \ldots, (i_n, f_n) \rangle$ la secuencia de los $n$ cursos ordenados por fecha de finalización en forma creciente, donde $i_j$ y $f_j$ son las fechas de inicio y finalización del $j$-ésimo curso, respectivamente, y $i_j \leq f_j$.

Definimos $C_j = \langle (i_1, f_1), \ldots, (i_j, f_j) \rangle$; es decir, $C_j$ es un prefijo de $C$ compuesto de sus primeros $j$ cursos. (Notemos que $C = C_n$.)

Llamamos $S(C)$ a la solución a nuestro problema, definida como una subsecuencia de $C$ de tamaño máximo tal que sus cursos no se solapan.

Podemos definir $S(C_n)$ recursivamente en función de una solución a un problema más pequeño $S(C_j)$ (con $j < n$) de la siguiente manera:

\begin{enumerate}
    \item{
        Si la secuencia es de tamaño $1$, la devolvemos sin modificar; es decir, $S(C_1) = C_1$.
    }

    \item{
        Si el $n$-ésimo curso no se solapa con ningún curso, entonces $S(C_n) = S(C_{n-1}) + \langle (i_n, f_n) \rangle$.\\
        Para que valga este caso, basta que se cumpla $f_{n-1} < i_n$.
    }

    \item\label{n-esimo-solapa}{
        Si el $n$-ésimo curso sí se solapa con algún otro curso, evaluamos las dos siguientes soluciones posibles y devolvemos la de mayor tamaño:

        \begin{enumerate}
            \item{
                Descartamos el $n$-ésimo curso y evaluamos $S(C_{n-1})$.
            }
            \item{
                Conservamos el $n$-ésimo curso y descartamos todos los cursos que se solapan con este.

                Para descartar los cursos que se solapan con el $n$-ésimo, buscamos el curso $(i_j, f_j)$ con fecha de finalización \textbf{más grande} que no se solape con el $n$-ésimo; es decir, tal que $f_j < i_n$. Esto nos garantiza que:

                \begin{itemize}
                    \item{
                        El $j$-ésimo y $n$-ésimo curso no se solapan.
                    }
                    
                    \item{
                        Los cursos $C_j = \langle (i_1, f_1), \ldots, (i_j, f_j) \rangle$ \textbf{tampoco} se solapan con el $n$-ésimo curso, pues $f_1 \leq \ldots \leq f_j \leq i_n$.
                    }

                    \item{
                        Los cursos $(i_{j+1}, f_{j+1}), \ldots, (i_n, f_n)$ \textbf{sí se solapan} con el $n$-ésimo curso, pues\\
                        $i_n \leq f_{j+1} \leq \ldots \leq f_n$.
                    }
                \end{itemize}

                Entonces evaluamos $S(C_j) + \langle (i_n, f_n) \rangle$.
            }
        \end{enumerate}
    }
\end{enumerate}

De esta forma evaluamos todas las soluciones posibles y devolvemos una solución óptima.

Ahora bien, esta solución recursiva presenta \textbf{superposición de problemas}. Por ejemplo, en el caso \ref{n-esimo-solapa} se evalúan las soluciones $S(C_{n-1})$ y $S(C_j)$. Como $n - 1 > j$, al evaluar $S(C_{n-1})$ eventualmente también se evalúa recursivamente $S(C_j)$, con lo que se terminaría evaluando $S(C_j)$ más de una vez.

Además, la solución presenta \textbf{subestructura óptima}: Si $S(C_n) = S(C_{n-1}) + \langle (i_n, f_n) \rangle$ es una solución óptima, entonces $S(C_{n-1})$ también lo es. Demostración: supongamos que $S(C_{n-1})$ es una solución subóptima de tamaño $m$. Entonces $S(C_n)$ es de tamaño $m + 1$. Supongamos ahora que existe una solución mejor para $C_{n-1}$, llamémosla $S_2(C_{n-1})$, de tamaño $2m$. Si aplicamos esta solución mejor en $S(C_n)$, tenemos $S(C_n) = S_2(C_{n-1}) + \langle (i_n, f_n) \rangle$, de longitud $2m + 1 \geq m + 1$. Absurdo, pues si la solución $S(C_n)$ original era óptima, no puede existir otra de longitud mayor. Luego, las soluciones de los subproblemas de una solución óptima también son óptimas.

Las dos características anteriores nos permiten aplicar la técnica de \textbf{programación dinámica} para resolver este problema.

Utilizamos un approach bottom up: computamos y memorizamos las soluciones a los subproblemas $S(C_1), \ldots, S(C_n)$ en ese orden, de forma que tener precomputados $S(C_1), \ldots, S(C_{j-1})$ al momento de computar un $S(C_j)$ cualquiera, y devolvemos $S(C_n)$ al finalizar.

\begin{pseudo}
    \Procedure{Profesores-visitantes}{$\langle (i_1, f_1), \ldots, (i_n, f_n) \rangle$}
        \State Pendiente.
    \EndProcedure 
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 3: Una noche en el museo                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Problema 3: Una noche en el museo}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusiones                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusiones}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\begin{appendices}

\section{Código fuente para el problema 1}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Código fuente para el problema 2}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 3                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Código fuente para el problema 3}

Pendiente.


\end{appendices}

\end{document}