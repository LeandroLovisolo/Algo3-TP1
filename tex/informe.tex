\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\usepackage{enumitem} % Provee macro \setlist
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 1 · Algoritmos y Estructuras de Datos III}
\rhead{Lovisolo · Petaccio · Rossi}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudo}[1][]{%
    \vspace{0.5em}%
    \begin{algorithmic}%
}
{%
    \end{algorithmic}%
    \vspace{0.5em}%
}

% Valores de verdad
\newcommand{\True}{\textbf{true}}
\newcommand{\False}{\textbf{false}}

% Conectivo 'in' para usar así: \ForAll{$foo$ \In $bar$}
\newcommand{\In}{\textbf{in} }

% Conectivo 'to' para usar así: \For{$i = 1$ \In $n$}
\newcommand{\To}{\textbf{to} }

% Complejidades
\newcommand{\Ode}[1]{\hfill $O(#1)$}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Deshabilita sangría en la primer línea de un párrafo.
\setlength{\parindent}{0em}

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


%%%%%%%%%% Gráficos - Inicio %%%%%%%%%%
% Macro para incluir tres gráficos (dentro de una figura) de manera que
% entren todos en una sola página.
\newcommand{\tresgraficos}[3]{
    \newcommand{\separacion}{-2.2em}
    \vspace{\separacion}
    \include{#1}
    \vspace{\separacion}
    \include{#2}
    \vspace{\separacion}
    \include{#3}
}
%%%%%%%%%% Gráficos - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 1
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Algoritmos y Estructuras de Datos III
\end{Large}

\vspace{1cm}

Segundo Cuatrimestre de 2013

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Leandro Lovisolo      & 645/11 & leandro@leandro.me\\
Lautaro José Petaccio & 443/11 & lausuper@gmail.com\\
Lucas Rossi           & 705/11 & lucasrossi20@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}

En el presente trabajo estudiamos tres problemas algorítmicos, proponemos soluciones para los mismos respetando sus requerimientos de complejidad temporal y analizamos empíricamente los tiempos de ejecución de sus implementaciones en lenguaje C++.

La motivación de este trabajo es comparar las cotas temporales obtenidas del análisis teórico con las mediciones de tiempos de ejecución y extraer conclusiones de esta experimentación.

Sin más, presentamos los problemas estudiados a continuación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 1: Pascual y el correo                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Problema 1: Pascual y el correo}

Dada una secuencia de paquetes y un límite de peso, se nos pide calcular, la cantidad de camiones necesarios y sus pesos, para realizar el transporte de los mismos, utilizando el método del encargado de logística llamado Pascual, el cuál consiste en lo siguiente:

\begin{itemize}
\item Si un paquete excede el peso del camión cargado con menor peso, se pide un nuevo camión y se coloca el paquete.
\item Si el paquete no supera el peso del camión cargado de menor peso, se lo coloca en el camión de menor peso.
\end{itemize}

Se nos pide resolver el problema con una cota de complejidad temporal \textbf{estrictamente mejor} que $O(n^2)$.

\textbf{Ejemplos del problema y sus soluciones:}

\textbf{Entrada}: límite: 100 , peso de paquetes: 3 80 40 60. \\
\textbf{Salida}: 2 80 100. \\
El camión 1 recibe el primer paquete de 80. Al intentar luego colocar el paquete de 40 en este, no le es posible debido a que el límite es 100 y lo guarda en el camión 2, al que luego, se le suma el paquete de 60, el cuál no provoca que el límite sea superado al colocarse en este.\\

\textbf{Entrada}: límite: 100, paquetes: 0.\\
\textbf{Salida}: 0. \\
Al no haber paquetes no se utilizan comiones, sin importar el límite del mismo.

\subsection{Solución}

Sea $\langle p_1, \ldots, p_n \rangle$ la secuencia que contiene los pesos de los $n$ paquetes en orden de llegada, sea $\langle c_1, \ldots, c_m \rangle$ la secuencia en orden ascendente que contiene las cargas de los camiones en un determinado momento (inicialmente vacía) y sea $L$ el límite de carga de los camiones.

Para cada paquete $p_i$, cargamos el paquete en el camión con menor carga $c_1$ si la nueva carga no supera el límite $L$, o en caso contrario agregamos un nuevo camión $c_{m+1} = p_i$ a la secuencia, realizando las permutaciones necesarias para preservar el orden ascendente.

Luego de haber cargado todos los paquetes, devolvemos la secuencia con la carga de cada camión.

Para cumplir con los requerimientos de complejidad temporal, utilizamos una cola de prioridad min-heap en lugar de una secuencia para almacenar las cargas de cada camión.

\begin{pseudo}
	\State Tipo de dato Camion es Tupla $\langle$ id : entero, carga : entero  $\rangle$
    \Procedure{Pascual-y-el-correo}{$\langle p_1, \ldots, p_n \rangle, L$}
        \State $C \leftarrow$ nuevo min-heap de Camion, ordenado por carga   \Ode{1}
        \ForAll{$p$ \In $\langle p_1, \ldots, p_n \rangle$}    	
            \If{$C.tama\tilde{n}o = 0$}                         \Ode{1}
                \State $C.encolar(\langle 1 , p \rangle)$       \Ode{log(n)}
            \ElsIf{$C.siguiente() + p \leq L$}                  \Ode{1}
                \State $c : Camion \leftarrow C.siguiente()$   \Ode{1}
                \State $c.carga \leftarrow c.carga + p$			\Ode{1}
                \State $C.desencolar()$                         \Ode{log(n)}
                \State $C.encolar(c)$                           \Ode{log(n)}
            \Else
                \State $C.encolar(\langle C.tama\tilde{n}o(), p \rangle)$ \Ode{log(n)}
            \EndIf
        \EndFor

  		\State $Camiones \leftarrow$ Arreglo de camiones de C.tamaño()
        \ForAll{$i$ \In $\langle 1, \ldots,$ C.tamaño() $\rangle$}			
      		\State Camiones[i] $\leftarrow$ $C.siguiente()$		\Ode{1}
      		\State $C.desencolar()$								\Ode{log(n)}
        \EndFor
        
        \State $Ordenar(Camiones)$ (Ordenamiento por id)		\Ode{log(n)}
        \State \textbf{return} $Camiones$
    \EndProcedure
\end{pseudo}


\subsection{Complejidad}

Para realizar el algoritmo se utilizó la estructura de datos priority\_queue que pertenece a la \textit{STL}.

Las operaciones operaciones utilizadas fueron \textit{top()} que corresponde a \textit{siguiente()} con complejidad \textit{O(1)} y \textit{push()} y \textit{pop()} que corresponden a \textit{encolar()} y \textit{desencolar()} con complejidad \textit{O(log(n))}.

El algoritmo corre en tiempo $O(n*log(n))$, donde $n$ es la cantidad de paquetes.

\textbf{Demostración:} para cada uno de los $n$ paquetes, se realizan 1 ó 2 operaciones $O(log(n))$ sobre la cola de prioridad. Luego deducimos la complejidad total $n * O(log(n)) = O(n * log(n))$.


\subsection{Correctitud}
Sea m el paquete número m de la secuencia de paquetes recibida, con m-1 paquetes ubicados en camiones anteriormente, quiero ver si al ubicar el paquete m el algoritmo cumple con la metodología de ordenar paquetes de Pascual.

Al utilizar una \textbf{cola de prioridad} para almacenar los camiones, es posible asegurar que siempre se tendrá el camión menos cargado en cada llamada a \textbf{siguiente()}, corroborando el correcto funcionamiento de la consigna, la cuál describe que las comparaciones para elegir el destino del paquete se hacen con el camión de menor peso. 

Si la suma del peso del camión menor cargado (conseguido con \textbf{siguiente()}) y el nuevo paquete m no superan el límite, se procede a desencolar del heap el camión. Se le carga el nuevo paquete aumentando su peso y se lo encola nuevamente en el heap.Este se encargará de dejar el nuevo camión disponible mediante \textbf{siguiente()}.

Si es requerido un nuevo camión, se crea uno nuevo con el peso del paquete m y se lo encola en el heap, nuevamente el heap se encargará de colocar el camión de menor peso de tal manera de estar disponible con \textbf{siguiente()}.

\subsection{Experimentos computacionales}
\subsubsection{Verificación de correctitud}
Elegimos los siguientes casos para verificar la correctitud del programa:
\begin{enumerate}
	\item Entrada vacía, verifica el comportamiento del algoritmo ante la posibilida de no recibir ningún paquete en la entrada.
	\item Entrada con un único paquete, verifica el primer caso, el de tener el \textbf{min-heap} vacío.
	\item Entrada en la cual en algún camión se deba insertar más de un paquete. Esto verifica el caso del \textbf{else if} descripto en el pseudocódigo.
	\item Entrada en la cual algún camión no pueda contener el peso del nuevo paquete y deba pedir un nuevo camión. Esto verifica el caso final (\textbf{else}), debiendo incluir un nuevo camión.
\end{enumerate}


\subsubsection{Performance}

Previo a los experimentos realizados suponiamos que el peor caso iba a ser cuando el tamaño de los paquetes sea igual al límite de los camiones, pero al realizarlos pudimos concluir que ese caso es el peor para Pascual, ya que tiene que utilizar una mayor cantidad de camiones y que el peor caso es cuando los paquetes están ordenados en forma decreciente, ya que se utiliza un min-heap como estructura y el camión a insertar tiene el peso mínimo
deberá reordenarse hasta llegar a la cabecera del heap realizando la mayor cantidad de operaciones posibles para la insersión.

Concluimos también en que tener una sucecesión de paquetes, los cuales entren todos en un solo camión, determina el mejor caso. Esto se debe a que sólo es necesaria la primera inserción en el heap, que como este es vacío es O(1) y luego no se utilizan otras operaciones sobre el heap que no sean O(1) (siguiente()) ya que sólo se carga un solo camión. Lo que lleva a tener una complejidad de $\Omega(n)$.

\subsubsection{Peor caso}

\begin{figure}[H]
  \centering
  \tresgraficos{problema1-peor-caso}
               {problema1-peor-caso-logn}
               {problema1-peor-caso-n}               
  \caption{Peor caso}
\end{figure}


\subsubsection{Mejor caso}

\begin{figure}[H]
  \centering
  \tresgraficos{problema1-mejor-caso}
               {problema1-mejor-caso-logn}
               {problema1-mejor-caso-n}
  \caption{Mejor caso}
\end{figure}


\subsubsection{Instancias aleatorias}

\begin{figure}[H]
  \centering
  \tresgraficos{problema1-instancias-aleatorias}
               {problema1-instancias-aleatorias-logn}
               {problema1-instancias-aleatorias-n}
  \caption{Instancias aleatorias}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 2: Profesores visitantes                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Problema 2: Profesores visitantes}

Dado un conjunto de $n$ cursos con una fecha de inicio y una fecha de finalización, se nos pide hallar el subconjunto con mayor cantidad de cursos tales que ningún curso se solapa con otro.

Se representa cada curso con una tupla $(i, f)$, donde $i$ y $f$ son las fechas de inicio y finalización del curso, respectivamente, tales que $i \leq f$.

Decimos que dos cursos $(i_1, f_1)$ y $(i_2, f_2)$ con $f_1 \leq f_2$ se solapan si y sólo si $f_1 \geq i_2$.

Formalmente, dado un conjunto de cursos $C = \{ (i_1, f_1), \ldots, (i_n, f_n) \}$, se nos pide hallar un subconjunto $S \subseteq C$ sin cursos solapados, tal que para cualquier otro $S' \subseteq C$ sin cursos solapados, vale que $|S| \geq |S'|$.

El problema debe ser resuelto con una cota de complejidad temporal \textbf{estrictamente mejor} que $O(n^2)$.

Algunas instancias del problema y sus soluciones:

\textbf{Entrada}: $\{(4, 4), (1, 3), (2, 5)\}$.\\
\textbf{Salida}: $\{(1, 3), (4, 4)\}$.

\textbf{Entrada}: $\{(4, 10), (5, 6), (2, 3), (7, 8), (3, 4), (1, 15)\}$.\\
\textbf{Salida}: $\{(2, 3), (5, 6), (7, 8)\}$ ó $\{(3, 4), (5, 6), (7, 8)\}$; cualquiera de las dos son correctas.

\textbf{Entrada}: $\{(1, 2)\}$.\\
\textbf{Salida}: $\{(1, 2)\}$.

\textbf{Entrada}: $\emptyset$.\\
\textbf{Salida}: $\emptyset$.


\subsection{Solución}

Sea $C = \{ (i_1, f_1), \ldots, (i_n, f_n) \}$ el conjunto con los $n$ cursos ordenados por fecha de finalización en forma creciente ($i < j \Rightarrow f_i \leq f_j$), y sea $S = \emptyset$ una solución del problema, inicialmente vacía.

Recorremos los cursos $c_j \in C$ (con $j = 1, \ldots, n$) en el orden anterior, realizando una de las siguientes acciones para cada $c_j$:

\begin{itemize}
    \item{
        Si $j = 1$, incluímos $c_1 = (i_1, f_1)$ en la solución: $S = \{ (i_1, f_1) \}$.
    }
    \item{
        Si $j > 1$ y $c_j = (i_j, f_j)$ \textbf{no se solapa} con el último curso agregado a la solución, lo incluímos en la misma: $S = S \cup \{ (i_j, f_j) \}$.
    }
    \item{
        En caso contrario, ignoramos $c_j$.
    }
\end{itemize}

Finalmente devolvemos la solución $S$ hallada.

En el pseudocódigo a continuación, $C$ denota el conjunto con la oferta de $n$ cursos $\{ (i_1, f_1), \ldots, (i_n, f_n) \}$.

\begin{pseudo}
    \Procedure{Profesores-visitantes}{$C$}
        \If{$|C| < 2$}
            \State{\Return{$C$}}                                \Ode{1}
        \Else
            \State{Ordenar $C$ por fecha de finalización
                   en forma creciente.}                         \Ode{n * log(n)}
            \State{$S = \{(i_1, j_1)\}$}                        \Ode{1}
            \State{$k = 1$}                                     \Ode{1}
            \For{$j = 2$ \To $|C|$}                            
                \If{$i_j > f_k$}                                \Ode{1}
                    \State{$S = S \cup \{ (i_j, f_j) \}$}       \Ode{1}
                    \State{$k = j$}                             \Ode{1}
                \EndIf
            \EndFor
            \State{\Return{$S$}}
        \EndIf
    \EndProcedure 
\end{pseudo}


\subsection{Complejidad}

El algoritmo corre en tiempo $O(n*log(n))$, donde $n$ es la cantidad de cursos.

\textbf{Demostración:} para el caso no trivial ($n > 1$) se ordenan los cursos en $O(n * log(n))$, luego se recorre cada curso y se decide si se lo incluye en la solución o no, con costo $n * O(1)$. La complejidad total resulta $O(n * log(n)) + n * O(1) = O(n * log(n) + n) = O(n * log(n))$. Para el caso trivial, se devuelve el conjunto de cursos intacto en tiempo constante.


\subsection{Correctitud}

El algoritmo incluye en la solución el curso que termina primero, descarta los cursos que se solapan con este y repite lo anterior con los cursos restantes hasta que no queden más cursos.

Para que el procedimiento anterior arroje una solución válida, tiene que cumplirse que para cualquier instancia del problema, el curso con fecha de finalización más temprana siempre sea parte de alguna solución. Si esto se cumple, podemos incluir dicho curso en nuestra solución, descartar todos los cursos que se solapan con este, resolver el subproblema resultante aplicando el mismo razonamiento e incluir la solución del subproblema en la solución al problema original.

El teorema a continuación muestra que la suposición anterior es de hecho cierta.

\newtheorem*{teorema-ej2}{Teorema}

\begin{teorema-ej2}
    Sea $C = \{ (i_1, f_1), \ldots, (i_n, f_n) \}$ la oferta de $n$ cursos ordenados por fecha de finalización de forma creciente. Entonces el curso $(i_1, f_1)$ está incluido en algún subconjunto de $C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima.
\end{teorema-ej2}

\begin{proof}
    Sea $S$ algún subconjunto $\subseteq C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima, y sea $(i_j, f_j)$ el curso $\in S$ con fecha de finalización más temprana.

    Si $(i_j, f_j) = (i_1, f_1)$ terminamos la demostración, pues hemos mostrado que $(i_1, f_1)$ está incluido en algún subconjunto de $C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima.

    Si $(i_j, f_j) \neq (i_1, f_1)$, entonces sea $S' = S - \{ (i_j, f_j) \} \cup \{ (i_1, f_1) \}$ el conjunto $S$ al que le reemplazamos $(i_j, f_j)$ por $(i_1, f_1)$. Los cursos en $S'$ no se solapan entre sí pues:

    \begin{itemize}[nolistsep]
        \item{los cursos en $S$ no se solapan entre sí,}
        \item{$(i_j, f_j)$ es la actividad en $S$ que termina primero, y}
        \item{$f_1 \leq f_j$.}
    \end{itemize}

    Como $|S'| = |S|$, concluímos que $S'$ es un subconjunto de $C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima, y $(i_1, f_1)$ está incluido en $S'$, como queríamos ver.
\end{proof}

\subsection{Experimentos computacionales}

\subsubsection{Performance}
Justificación de la elección de peor o mejor caso y hablar de cómo se generaron los casos aleatorios.
PEOR Y MEJOR CASO DEPENDIENDO DEL ALGORITMO DE ORDENAMIENTO.
Si se utiliza heap sort, peor y mejor caso iguales.

\subsubsection{Peor caso}

\begin{figure}[H]
  \centering
  \tresgraficos{problema2-peor-caso}
               {problema2-peor-caso-logn}
               {problema2-peor-caso-n}               
  \caption{Peor caso}
\end{figure}


\subsubsection{Mejor caso}

\begin{figure}[H]
  \centering
  \tresgraficos{problema2-mejor-caso}
               {problema2-mejor-caso-logn}
               {problema2-mejor-caso-n}
  \caption{Mejor caso}
\end{figure}


\subsubsection{Instancias aleatorias}

\begin{figure}[H]
  \centering
  \tresgraficos{problema2-instancias-aleatorias}
               {problema2-instancias-aleatorias-logn}
               {problema2-instancias-aleatorias-n}
  \caption{Instancias aleatorias}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 3: Una noche en el museo                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Problema 3: Una noche en el museo}
Se desea instalar un sistema de detección de movimientos basado en sensores láser, para esto cada piso del museo fue modelado por una grilla de $n$ $x$ $m$ casillas.

Existen dos tipos de sensores, bidireccionales (emiten señales hacia la izquierda y la derecha o bien hacia arriba y abajo) y cuatridireccionales (emiten señales en las 4 direcciones), de \$4000 y \$6000 respectivamente y 3 tipos de casilla, vacía, importante y pared.

Dado un piso se debe cumplir:

\begin{itemize}
\item las casillas libres deben quedar cubiertas por al menos un sensor.
\item las casilla importantes deben ser cubiertas por dos sensores.
\item no se puede ubicar un sensor de forma tal que alguna de sus señales impacten contra otro dispositivo.
\item no se puede instalar más de un dispositivo en una misma casilla libre.
\item en caso de haber solución, la misma debrá minimizar la cantidad de dinero invertido en sensores.
\end{itemize}

Se pide realizar el algoritmo mediante la técnica de Backtracking.

\textbf{Ejemplo:}
\begin{figure}[H]
  \centering
\includegraphics[width=0.20\textwidth]{ejemplo_problema3/grilla.png}
\includegraphics[width=0.20\textwidth]{ejemplo_problema3/grilla-sol16000.png}
\includegraphics[width=0.20\textwidth]{ejemplo_problema3/grilla-sol14000.png}
\includegraphics[width=0.20\textwidth]{ejemplo_problema3/grillaSinSol.png}
  \caption{Instacia del problema, dos soluciones distintas con un costo de \$14.000 y \$16.000 respectivamente y una solución no válida} 
  \label{fig:1}
\end{figure}


\subsection{Solución}

% Posiciones posibles
\newcommand{\Libre}{\texttt{Libre}}
\newcommand{\Sensado}{\texttt{Sensado}}
\newcommand{\Importante}{\texttt{Importante}}
\newcommand{\Pared}{\texttt{Pared}}
\newcommand{\SensorV}{\texttt{SensorVertical}}
\newcommand{\SensorH}{\texttt{SensorHorizontal}}
\newcommand{\SensorC}{\texttt{SensorCuadruple}}

Representamos un piso $P$ como una matriz de $m$ filas por $n$ columnas, donde cada $p_{ij} \in P$ tiene cualquiera de los siguientes valores: \Libre, \Sensado, \Importante, \Pared, \SensorV, \SensorH, \SensorC.

Dado un piso $P$ sin sensores, recorremos el árbol de combinaciones de sensores posibles en búsqueda de una solución óptima de la siguiente manera:

\begin{enumerate}
    \item{
        \label{buscar-posicion-libre}
        Buscamos la primera posición libre $(i, j)$ recorriendo el piso de izquierda a derecha y de arriba a abajo, partiendo de la esquina superior izquierda.

        \begin{pseudo}
            \State $i \leftarrow 1$, $j \leftarrow 1$             \Ode{1}
            \While{$i \leq m \land p_{ij} \neq \Libre$}           \Ode{m \times n}
                \If{$j < n$}                                      \Ode{1}
                    \State $j \leftarrow j + 1$                   \Ode{1}
                \Else                                             \Ode{1}
                    \State $i \leftarrow i + 1$, $j \leftarrow 1$ \Ode{1}
                \EndIf
            \EndWhile
        \end{pseudo}

         Si no encontramos ninguna posición libre (es decir, si $i > m$), saltamos al paso \ref{ultimo-paso}.
    }
    \item{
        \label{generar-pisos}
        Generamos 4 pisos nuevos, copiando el piso $P$ y:
        \begin{enumerate}
            \item{
                Poniendo un sensor vertical en $(i, j)$. \Ode{m \times n}
            }
            \item{
                Poniendo un sensor horizontal en $(i, j)$. \Ode{m \times n}
            }
            \item{
                Poniendo un sensor cuádruple en $(i, j)$. \Ode{m \times n}
            }
            \item{
                \label{posicion-libre}
                Dejando libre la posición $(i, j)$ (es decir, este nuevo piso es idéntico al piso $P$.) \Ode{m \times n}
            }
        \end{enumerate}
    }
    \item{
        Para cada piso $Q$ generado en el paso anterior, marcamos como sensadas todas las posiciones libres afectadas por el nuevo sensor (no aplica para el caso \ref{posicion-libre}.)

        \begin{pseudo}
            \If{$q_{ij} \in \{ \SensorV, \SensorC \}$}                                   \Ode{m}
                \For{$i'$ \In $\textsc{Columna-Visible}(q_{ij})$}                        \Ode{m}
                    \State $q_{i'j} \leftarrow \Sensado$ \textbf{if} $q_{i'j} = \Libre$  \Ode{1}
                \EndFor
            \EndIf
            \If{$q_{ij} \in \{ \SensorH, \SensorC \}$}                                   \Ode{n}
                \For{$j'$ \In $\textsc{Fila-Visible}(q_{ij})$}                           \Ode{n}
                    \State $q_{ij'} \leftarrow \Sensado$ \textbf{if} $q_{ij'} = \Libre$  \Ode{1}
                \EndFor
            \EndIf
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Fila-Visible}{$q_{ij}$}                            \Ode{n}
                \State $C \leftarrow \{ j \}$                             \Ode{n}
                \For{$rango$ \In $\{ (j, \ldots, 1), (j, \ldots, n)  \}$} \Ode{2*n}
                    \For{$j'$ \In $rango$}                                \Ode{n}
                        \State \textbf{break if} $q_{ij'} = \Pared$       \Ode{1}
                        \State $C \leftarrow C \cup \{ j' \}$             \Ode{1}
                    \EndFor
                \EndFor
                \State \Return{$C$}                                       \Ode{1}
            \EndProcedure
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Columna-Visible}{$q_{ij}$}                         \Ode{m}
                \State $F \leftarrow \{ i \}$                             \Ode{1}
                \For{$rango$ \In $\{ (i, \ldots, 1), (i, \ldots, m)  \}$} \Ode{2*m}
                    \For{$i'$ \In $rango$}                                \Ode{m}
                        \State \textbf{break if} $q_{i'j} = \Pared$       \Ode{1}
                        \State $F \leftarrow F \cup \{ i' \}$             \Ode{1}
                    \EndFor
                \EndFor
                \State \Return{$F$}                                       \Ode{1}
            \EndProcedure
        \end{pseudo}
    }
    \item{
        Para cada piso $Q$ resultante del paso anterior, descartamos los que correspondan según el criterio de poda (ver \textit{Podas} más abajo.)
    }
    \item{
        \label{paso-recursivo}
        Para cada piso $Q$ que no fue descartado en el paso anterior:
        \begin{enumerate}
            \item{
                Buscamos la siguiente posición libre $(i', j')$ de la misma manera que en el paso \ref{buscar-posicion-libre}, pero partiendo de $(i, j+1)$ en vez de la esquina superior izquierda, ó $(i+1, 1)$ si $j=n$. \Ode{m \times n}
            }
            \item{
                Si encontramos una posición libre, repetimos los pasos $\ref{generar-pisos}, \ldots, \ref{paso-recursivo}$ utilizando $Q$ en lugar de $P$, y $(i', j')$ en lugar de $(i, j)$.
            }
            \item{
                En caso contrario, decidimos si el piso es solución.

                \begin{pseudo}
                    \State $esSolucion \leftarrow \True$                                       \Ode{1}
                    \For{$i$ \In $1, \ldots, m$, $j$ \In $1, \ldots, n$}                       \Ode{m \times n \times (m + n)}
                        \If{$q_{ij} = \Importante$}                                            \Ode{m + n}
                            \State $s \leftarrow \textsc{\#-Sensores-Actuando-Sobre}(q_{ij})$  \Ode{m + n}
                        \EndIf

                        \If{$q_{ij} = \Libre$ $\lor$ $(q_{ij} = \Importante$ $\land$ $s < 2)$} \Ode{1}
                            \State $esSolucion \leftarrow \False$                              \Ode{1}
                            \State \textbf{break}
                        \EndIf
                    \EndFor
                \end{pseudo}

                \begin{pseudo}
                    \Procedure{\#-Sensores-Actuando-Sobre}{$q_{ij}$}      \Ode{m + n}
                        \State $s \leftarrow 0$                           \Ode{1}
                        \For{$i'$ \In $\textsc{Columna-Visible}(q_{ij})$} \Ode{m}
                            \If{$q_{i'j} \in \{ \SensorV, \SensorC \}$}   \Ode{1}
                                \State $s \leftarrow s + 1$               \Ode{1}
                                \State \textbf{break}
                            \EndIf
                        \EndFor
                        \For{$j'$ \In $\textsc{Fila-Visible}(q_{ij})$}    \Ode{n}
                            \If{$q_{ij'} \in \{ \SensorH, \SensorC \}$}   \Ode{1}
                                \State $s \leftarrow s + 1$               \Ode{1}
                                \State \textbf{break}
                            \EndIf
                        \EndFor
                        \State \Return{$s$}                               \Ode{1}
                    \EndProcedure
                \end{pseudo}


            }
            \item{
                Si es solución y es más barata que la mejor solución $S$ hallada hasta el momento, o si aún no se halló ninguna solución, la marcamos como mejor solución.

                \begin{pseudo}
                    \If{$esSolucion$}
                        \If{$S = \textbf{nil}$ $\lor$ $\textsc{Costo}(Q) < \textsc{Costo}(S)$} \Ode{m \times n}
                            \State $S \leftarrow Q$ (referencia)                               \Ode{1}
                        \EndIf
                    \EndIf
                \end{pseudo}

                \begin{pseudo}
                    \Procedure{Costo}{$Q$}                                            \Ode{m \times n}
                        \State $c \leftarrow 0$                                       \Ode{1}
                        \For{$i$ \In $1, \ldots, m$, $j$ \In $1, \ldots, n$}          \Ode{m \times n}
                            \State $c \leftarrow c + 4000$
                                    \textbf{if} $q_{ij} \in \{ \SensorV, \SensorH \}$ \Ode{1}
                            \State $c \leftarrow c + 6000$
                                \textbf{if} $q_{ij} = \SensorC$                       \Ode{1}
                        \EndFor
                        \State \Return{$c$}                                           \Ode{1}
                    \EndProcedure
                \end{pseudo}                
            }
        \end{enumerate}
    }
    \item{
        \label{ultimo-paso}
        Devolvemos la mejor solución hallada $S$, que puede ser \textbf{nil} en caso de no haberse hallado una.
    }
\end{enumerate}


\subsubsection{Podas}

Las podas a continuación se realizan siempre para cada piso $Q$ generado en el paso \ref{generar-pisos}, donde $q_{ij}$ es la posición que se modificó (o se dejó intacta en el caso \ref{posicion-libre}) luego de copiar el piso $P$ original.

\begin{enumerate}
    \item{
        Si $q_{ij} \in \{ \SensorV, \SensorH, \SensorC \}$, podamos si su señal impacta otro sensor o viceversa; es decir, si $\textsc{Impacta-Otro-Sensor}(q_{ij}) = \True$.

        \begin{pseudo}
            \Procedure{Impacta-Otro-Sensor}{$q_{ij}$}                       \Ode{m + n}
                \For{$i'$ \In $\textsc{Columna-Visible}(q_{ij})$}           \Ode{m}
                    \If{$\textsc{Sensores-Incompatibles}(q_{ij}, q_{i'j})$} \Ode{1}
                        \State \Return{\True}                               \Ode{1}
                    \EndIf
                \EndFor
                \For{$j'$ \In $\textsc{Fila-Visible}(q_{ij})$}              \Ode{n}
                    \If{$\textsc{Sensores-Incompatibles}(q_{ij}, q_{ij'})$} \Ode{1}
                        \State \Return{\True}                               \Ode{1}
                    \EndIf
                \EndFor
                \State \Return{\False}                                      \Ode{1}
            \EndProcedure
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Sensores-Incompatibles}{$q_{ij}, q_{i'j'}$}     \Ode{1}
                \If{$i = i'$}                                          \Ode{1}
                    \If{$\textsc{Sensa-Horizontalmente}(q_{ij}) \lor
                            \textsc{Sensa-Horizontalmente}(q_{i'j'})$} \Ode{1}
                        \State \Return{\True}                          \Ode{1}
                    \EndIf
                \EndIf
                \If{$j = j'$}                                          \Ode{1}
                    \If{$\textsc{Sensa-Verticalmente}(q_{ij}) \lor
                            \textsc{Sensa-Verticalmente}(q_{i'j'})$}   \Ode{1}
                        \State \Return{\True}                          \Ode{1}
                    \EndIf
                \EndIf
                \State \Return{\False}                                 \Ode{1}
            \EndProcedure
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Sensa-Verticalmente}{$q_{ij}$}                 \Ode{1}
                \State \Return{$q_{ij} \in \{ \SensorV, \SensorC \}$} \Ode{1}
            \EndProcedure
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Sensa-Horizontalmente}{$q_{ij}$}               \Ode{1}
                \State \Return{$q_{ij} \in \{ \SensorH, \SensorC \}$} \Ode{1}
            \EndProcedure
        \end{pseudo}
    }
    \item{
        Si $q_{ij} \in \{ \SensorV, \SensorH \}$, podamos si produce que una posición libre en su misma fila o columna sea imposible de sensar.

        Esto ocurre cuando existe un sensor vertical y un sensor horizontal en la misma fila y columna de una posición libre, respectivamente, y no hay una pared entre los sensores y esa posición.

        \begin{pseudo}
            \State $podar \leftarrow \False$                                           \Ode{1}
            \If{$q_{ij} = \SensorV$}                                                   \Ode{m \times n}
                \For{$j'$ \In $\textsc{Fila-Visible}(q_{ij})$}                         \Ode{m \times n}
                    \If{$q_{ij'} = \Libre \land
                            \textsc{Hay-Un-Sensor-Horizontal-En-Su-Columna}(q_{ij'})$} \Ode{m}
                        \State $podar \leftarrow \True$                                \Ode{1}
                        \State \textbf{break}
                    \EndIf
                \EndFor
            \EndIf
            \If{$q_{ij} = \SensorH$}                                                   \Ode{1}
                \For{$i'$ \In $\textsc{Columna-Visible}(q_{ij})$}                      \Ode{m \times n}
                    \If{$q_{i'j} = \Libre \land
                            \textsc{Hay-Un-Sensor-Vertical-En-Su-Fila}(q_{i'j})$}      \Ode{n}
                        \State $podar \leftarrow \True$                                \Ode{1}
                        \State \textbf{break}
                    \EndIf
                \EndFor
            \EndIf
            \State Podamos $Q$ si $podar = \True$.
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Hay-Un-Sensor-Horizontal-En-Su-Columna}{$q_{ij}$} \Ode{m}
                \For{$i'$ \In $\textsc{Columna-Visible}(q_{ij})$}        \Ode{m}
                    \If{$q_{i'j} = \SensorH$}                            \Ode{1}
                        \State \Return{\True}                            \Ode{1}
                    \EndIf
                \EndFor
                \State \Return{\False}                                   \Ode{1}
            \EndProcedure
        \end{pseudo}

        \begin{pseudo}
            \Procedure{Hay-Un-Sensor-Vertical-En-Su-Fila}{$q_{ij}$} \Ode{n}
                \For{$j'$ \In $\textsc{Fila-Visible}(q_{ij})$}      \Ode{n}
                    \If{$q_{ij'} = \SensorV$}                       \Ode{1}
                        \State \Return{\True}                       \Ode{1}
                    \EndIf
                \EndFor
                \State \Return{\False}                              \Ode{1}
            \EndProcedure
        \end{pseudo}
    }
    \item{
        Si $q_{ij} \in \{ \SensorV, \SensorH, \SensorC \}$, podamos si el costo del piso supera o iguala el de la mejor solución $S$ hallada hasta el momento; es decir, si $\textsc{Costo}(Q) \geq \textsc{Costo}(S)$.
    }
    \item{
        Si $q_{ij} = \Libre$, podamos si $q_{ij}$ es imposible de sensar.

        Esto ocurre cuando no existe otra posición libre en su misma fila o columna sin una pared entre ambas, tal que se pueda poner un sensor apuntando a la misma, sin que su señal impacte otros sensores o viceversa.

        \begin{pseudo}
            \State $podar \leftarrow \True$                               \Ode{1}
            \For{$i'$ \In $\textsc{Columna-Visible}(q_{ij})$}             \Ode{m^2 \times n}
                \If{$q_{i'j} = \Libre$}                                   \Ode{m \times n}
                    \State $R \leftarrow Q$ (copia)                       \Ode{m \times n}
                    \State $r_{i'j} \leftarrow \SensorV$                  \Ode{1}
                    \If{$\textsc{Impacta-Otro-Sensor}(r_{i'j}) = \False$} \Ode{m + n}
                        \State $podar \leftarrow \False$                  \Ode{1}
                    \EndIf
                \EndIf
            \EndFor
            \For{$j'$ \In $\textsc{Fila-Visible}(q_{ij})$}                \Ode{m \times n^2}
                \If{$q_{ij'} = \Libre$}                                   \Ode{m \times n}
                    \State $R \leftarrow Q$ (copia)                       \Ode{m \times n}
                    \State $r_{ij'} \leftarrow \SensorV$                  \Ode{1}
                    \If{$\textsc{Impacta-Otro-Sensor}(r_{ij'}) = \False$} \Ode{m + n}
                        \State $podar \leftarrow \False$                  \Ode{1}
                    \EndIf
                \EndIf
            \EndFor
            \State Podamos $Q$ si $podar = \True$.
        \end{pseudo}
    }
\end{enumerate}


\subsection{Complejidad}

Pendiente.


\subsection{Correctitud}

Para demostrar la correctitud del algoritmo, se debe demostrar lo siguiente:
\begin{enumerate}
  \item Probar que recorremos todo el espacio de pisos posibles.
    \item Probar que solo podamos las ramas que conducen a pisos que no son solución.
    \item Probar que los pisos obtenidos son solución.
    \item Probar que la solución devuelta es la óptima.
\end{enumerate}

\subsubsection{Se recorre todo el espacio de pisos posibles}

El procedimiento mediante el cuál se recorre recursivamente el árbol de decisiones es \textbf{recorrer()}.

Dado un piso, para el primer casillero libre, siguiendo con el orden en que se lo recorre, se generan 4 instacias posibles (sensor horizontal, sensor vertical, sensor cuádruple y casillero libre), luego para cada una de las instancias se realiza el mismo procedimiento hasta cubrir todo el piso, de esta forma se recorre la totalidad de los posibles pisos existentes, que en el peor caso serian $4^{nxm}$.\\


\textbf{Pseudocódigo de las llamadas recurivas para los distintos tipos de casillero}

\begin{pseudo}
  \State Piso q $\leftarrow$ Copia(piso)
    \State ubicarSensor(q, fila, columna, TipoDeSensor)
  \State recorrer(q, fila, columna, iteracion)
\end{pseudo}


\subsubsection{Se podan las ramas que conducen a pisos que no son soluciones}

Las podas se realizan mediante la llamada a \textbf{podar()} desde \textbf{recorrer()}.
Para probar que estas realizan un trabajo correcto, estas deben seguir las normas del tablero.

\textbf{Utilizando la poda 1)}, eliminamos las ramas de soluciones que tengan sensores incompatibles entre si, es decir, sensores que se esten sensando al mismo tiempo.

\textbf{Utilizando la poda 3)}, eliminamos las soluciones de un costo mayor a la actualmente encontrada. Este procedimiento produce soluciones correctas y mínimas (sin obviar otras soluciones mínimas posibles) ya que, teniendo un costo de una solución, pueden ocurrir los siguientes casos:

\begin{itemize}
\item La inserción de un nuevo sensor incrementará el costo de la solución, haciendo que esta sea peor.
\item Si esta fuera igual, podría llegar a una solución, mínima también, pero ya tenemos una de igual costo, por lo que su recorrido es innecesario.
\item La rama de soluciones por la que se está buscando una solución sigue siendo menor a la solución encontrada anteriormente, llevando a una potencial mejor solución en el caso de que exista.
\end{itemize}

\subsubsection{Los pisos obtenidos son soluciones}

Al haberse recorrido todos los casilleros se chequea que el resultado sea una solucion y esto ocurre si todos los casilleros libres estan estan sensados y si los cosilleros importantes estan doblemente sensados.

Debido a que una solución es una hoja del árbol de soluciones posibles, este debe de haber pasado antes por las podas, verificando también la correctiud de los sensores.


\subsubsection{La solución devuelta es la óptima}
Debido a que se utiliza como poda no recorrer las ramas que llevan a soluciones de mayor costo al costo de la solución de menor costo obtenida, la solución a la cuál se llega siempre tendrá solución óptima, es decir, su solución siempre tendrá costo mínimo.


\subsection{Experimentos computacionales}

\subsubsection{Performance}
Justificación de la elección del mejor, peor caso y descripción de casos aleatorios.

\subsubsection{Peor caso}

\begin{figure}[H]
  \centering
  \include{problema3-peor-caso}
  \caption{Peor caso}
\end{figure}


\subsubsection{Mejor caso}

\begin{figure}[H]
  \centering
  \include{problema3-mejor-caso}
  \caption{Mejor caso}
\end{figure}


\subsubsection{Instancias aleatorias}

\begin{figure}[H]
  \centering
  \include{problema3-instancias-aleatorias}
  \caption{Instancias aleatorias}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusiones                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Conclusiones}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\begin{appendices}

\section{Código fuente para el problema 1}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Código fuente para el problema 2}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 3                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Código fuente para el problema 3}

Pendiente.


\end{appendices}

\end{document}