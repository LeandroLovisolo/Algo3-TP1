\documentclass[a4paper,10pt,twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-ucroman,es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{algpseudocode}
\usepackage{enumitem} % Provee macro \setlist
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 1 · Algoritmos y Estructuras de Datos III}
\rhead{Lovisolo · Petaccio · Rossi}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudo}[1][]{%
    \vspace{0.5em}%
    \begin{algorithmic}%
}
{%
    \end{algorithmic}%
    \vspace{0.5em}%
}

% Conectivo 'in' para usar así: \ForAll{$foo$ \In $bar$}
\newcommand{\In}{\textbf{in} }

% Conectivo 'to' para usar así: \For{$i = 1$ \In $n$}
\newcommand{\To}{\textbf{to} }

% Complejidades
\newcommand{\Ode}[1]{\hfill $O(#1)$}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Deshabilita sangría en la primer línea de un párrafo.
\setlength{\parindent}{0em}

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 1
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Algoritmos y Estructuras de Datos III
\end{Large}

\vspace{1cm}

Segundo Cuatrimestre de 2013

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Leandro Lovisolo      & 645/11 & leandro@leandro.me\\
Lautaro José Petaccio & 443/11 & lausuper@gmail.com\\
Lucas Rossi           & 705/11 & lucasrossi20@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}

En el presente trabajo estudiamos tres problemas algorítmicos, proponemos soluciones para los mismos respetando sus requerimientos de complejidad temporal y analizamos empíricamente los tiempos de ejecución de sus implementaciones en lenguaje C++.

La motivación de este trabajo es comparar las cotas temporales obtenidas del análisis teórico con las mediciones de tiempos de ejecución y extraer conclusiones de esta experimentación.

Sin más, presentamos los problemas estudiados a continuación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 1: Pascual y el correo                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Problema 1: Pascual y el correo}

Dada una secuencia de paquetes y un límite de peso, se nos pide calcular, la cantidad de camiones necesarios y sus pesos, para realizar el transporte de los mismos, utilizando el método del encargado de logística llamado Pascual, el cuál consiste en lo siguiente:

\begin{itemize}
\item Si un paquete excede el peso del camión cargado con menor peso, se pide un nuevo camión y se coloca el paquete.
\item Si el paquete no supera el peso del camión cargado de menor peso, se lo coloca en el camión de menor peso.
\end{itemize}

Se nos pide resolver el problema con una cota de complejidad temporal \textbf{estrictamente mejor} que $O(n^2)$.

\textbf{Ejemplos del problema y sus soluciones:}
\begin{itemize}
	\item El formato de entrada es el siguiente: \\
  límite cantidadDePaquetes paquete1 paquete 2... \#
	\item El formato de salida es el siguiente: \\
	cantidadDeCamiones pesoCamion1 pesoCamion2 ...
\end{itemize}

\textbf{Entrada}: 100 3 80 40 60 \#.\\
\textbf{Salida}: 2 80 100. \\
El camión 1 recibe el primer paquete de 80. Al intentar luego colocar el paquete de 40 en este, no le es posible debido a que el límite es 100 y lo guarda en el camión 2, al que luego, se le suma el paquete de 60, el cuál no provoca que el límite sea superado al colocarse en este.\\

\textbf{Entrada}: 100 0\#.\\
\textbf{Salida}: 0. \\
Al no haber paquetes no se utilizan comiones, sin importar el límite del mismo.

\subsection{Solución}

Sea $\langle p_1, \ldots, p_n \rangle$ la secuencia que contiene los pesos de los $n$ paquetes en orden de llegada, sea $\langle c_1, \ldots, c_m \rangle$ la secuencia en orden ascendente que contiene las cargas de los camiones en un determinado momento (inicialmente vacía) y sea $L$ el límite de carga de los camiones.

Para cada paquete $p_i$, cargamos el paquete en el camión con menor carga $c_1$ si la nueva carga no supera el límite $L$, o en caso contrario agregamos un nuevo camión $c_{m+1} = p_i$ a la secuencia, realizando las permutaciones necesarias para preservar el orden ascendente.

Luego de haber cargado todos los paquetes, devolvemos la secuencia con la carga de cada camión.

Para cumplir con los requerimientos de complejidad temporal, utilizamos una cola de prioridad min-heap en lugar de una secuencia para almacenar las cargas de cada camión.

\begin{pseudo}
    \Procedure{Pascual-y-el-correo}{$\langle p_1, \ldots, p_n \rangle, L$}
        \State $C \leftarrow$ nuevo min-heap                    \Ode{1}
        \ForAll{$p$ \In $\langle p_1, \ldots, p_n \rangle$}     \Ode{1}
            \If{$C.tama\tilde{n}o = 0$}                         \Ode{1}
                \State $C.encolar(p)$                           \Ode{log(n)}
            \ElsIf{$C.siguiente() + p \leq L$}                  \Ode{1}
                \State $c \leftarrow C.siguiente() + p$         \Ode{1}
                \State $C.desencolar()$                         \Ode{log(n)}
                \State $C.encolar(c)$                           \Ode{log(n)}
            \Else
                \State $C.encolar(c)$                           \Ode{log(n)}
            \EndIf
        \EndFor
        \State \textbf{return} $C$
    \EndProcedure
\end{pseudo}


\subsection{Complejidad}

El algoritmo corre en tiempo $O(n*log(n))$, donde $n$ es la cantidad de paquetes.

Demostración: para cada uno de los $n$ paquetes, se realizan 1 ó 2 operaciones $O(log(n))$ sobre la cola de prioridad. Luego deducimos la complejidad total $n * O(log(n)) = O(n * log(n))$.


\subsection{Correctitud}
Sea m el paquete número m de la secuencia de paquetes recibida, con m-1 paquetes ubicados en camiones anteriormente, quiero ver si al ubicar el paquete m el algoritmo cumple con la metodología de ordenar paquetes de Pascual.

Al utilizar un \textbf{min-heap} como estructura para almacenar los camiones, es posible asegurar que siempre se tendrá el camión menos cargado, corroborando el correcto funcionamiento de la consigna, la cuál describe que las comparaciones para elegir el destino del paquete se hacen con el camión de menor peso. 

Si la suma del peso del camión en la cabecera y el nuevo paquete m no superan el límite, se procede a desencolar del heap el camión, se le carga el nuevo paquete aumentando su peso y se lo encola nuevamente en el heap el cuál se encargará de dejar el nuevo camión con menos peso en la cabecera.

Si es requerido un nuevo camión, se crea uno nuevo con el peso del paquete m y se lo encola en el heap, nuevamente el heap se encargará de colocar el camión de menor peso en la cabecera.

\subsection{Experimentos computacionales}
\subsubsection{Verificación de correctitud}
Elegimos los siguientes casos para verificar la correctitud del programa:
\begin{enumerate}
	\item Entrada vacía, verifica el comportamiento del algoritmo ante la posibilida de no recibir ningún paquete en la entrada.
	\item Entrada con un único paquete, verifica el primer caso, el de tener el \textbf{min-heap} vacío.
	\item Entrada en la cual en algún camión se deba insertar más de un paquete. Esto verifica el caso del \textbf{else if} descripto en el pseudocódigo.
	\item Entrada en la cual algún camión no pueda contener el peso del nuevo paquete y deba pedir un nuevo camión. Esto verifica el caso final (\textbf{else}), debiendo incluir un nuevo camión.
\end{enumerate}

\subsubsection{Performance}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 2: Profesores visitantes                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Problema 2: Profesores visitantes}

Dado un conjunto de $n$ cursos con una fecha de inicio y una fecha de finalización, se nos pide hallar el subconjunto con mayor cantidad de cursos tales que ningún curso se solapa con otro.

Se representa cada curso con una tupla $(i, f)$, donde $i$ y $f$ son las fechas de inicio y finalización del curso, respectivamente, tales que $i \leq f$.

Decimos que dos cursos $(i_1, f_1)$ y $(i_2, f_2)$ con $f_1 \leq f_2$ se solapan si y sólo si $f_1 \geq i_2$.

Formalmente, dado un conjunto de cursos $C = \{ (i_1, f_1), \ldots, (i_n, f_n) \}$, se nos pide hallar un subconjunto $S \subseteq C$ sin cursos solapados, tal que para cualquier otro $S' \subseteq C$ sin cursos solapados, vale que $|S| \geq |S'|$.

El problema debe ser resuelto con una cota de complejidad temporal \textbf{estrictamente mejor} que $O(n^2)$.

Algunas instancias del problema y sus soluciones:

\textbf{Entrada}: $\{(4, 4), (1, 3), (2, 5)\}$.\\
\textbf{Salida}: $\{(1, 3), (4, 4)\}$.

\textbf{Entrada}: $\{(4, 10), (5, 6), (2, 3), (7, 8), (3, 4), (1, 15)\}$.\\
\textbf{Salida}: $\{(2, 3), (5, 6), (7, 8)\}$ ó $\{(3, 4), (5, 6), (7, 8)\}$; cualquiera de las dos son correctas.

\textbf{Entrada}: $\{(1, 2)\}$.\\
\textbf{Salida}: $\{(1, 2)\}$.

\textbf{Entrada}: $\emptyset$.\\
\textbf{Salida}: $\emptyset$.


\subsection{Solución}

Sea $C = \{ (i_1, f_1), \ldots, (i_n, f_n) \}$ el conjunto con los $n$ cursos ordenados por fecha de finalización en forma creciente ($i < j \Rightarrow f_i \leq f_j$), y sea $S = \emptyset$ una solución del problema, inicialmente vacía.

Recorremos los cursos $c_j \in C$ (con $j = 1, \ldots, n$) en el orden anterior, realizando una de las siguientes acciones para cada $c_j$:

\begin{itemize}
    \item{
        Si $j = 1$, incluímos $c_1 = (i_1, f_1)$ en la solución: $S = \{ (i_1, f_1) \}$.
    }
    \item{
        Si $j > 1$ y $c_j = (i_j, f_j)$ \textbf{no se solapa} con el último curso agregado a la solución, lo incluímos en la misma: $S = S \cup \{ (i_j, f_j) \}$.
    }
    \item{
        En caso contrario, ignoramos $c_j$.
    }
\end{itemize}

Finalmente devolvemos la solución $S$ hallada.

En el pseudocódigo a continuación, $C$ denota el conjunto con la oferta de $n$ cursos $\{ (i_1, f_1), \ldots, (i_n, f_n) \}$.

\begin{pseudo}
    \Procedure{Profesores-visitantes}{$C$}
        \If{$|C| < 2$}
            \State{\Return{$C$}}                                \Ode{1}
        \Else
            \State{Ordenar $C$ por fecha de finalización
                   en forma creciente.}                         \Ode{n * log(n)}
            \State{$S = \{(i_1, j_1)\}$}                        \Ode{1}
            \State{$k = 1$}                                     \Ode{1}
            \For{$j = 2$ \To $|C|$}                             \Ode{n}
                \If{$i_j > f_k$}                                \Ode{1}
                    \State{$S = S \cup \{ (i_j, f_j) \}$}       \Ode{1}
                    \State{$k = j$}                             \Ode{1}
                \EndIf
            \EndFor
            \State{\Return{$S$}}
        \EndIf
    \EndProcedure 
\end{pseudo}


\subsection{Complejidad}

El algoritmo corre en tiempo $O(n*log(n))$, donde $n$ es la cantidad de cursos.

Demostración: para el caso no trivial ($n > 1$) se ordenan los cursos en $O(n * log(n))$, luego se recorre cada curso y se decide si se lo incluye en la solución o no, con costo $n * O(1)$. La complejidad total resulta $O(n * log(n)) + n * O(1) = O(n * log(n) + n) = O(n * log(n))$. Para el caso trivial, se devuelve el conjunto de cursos intacto en tiempo constante.


\subsection{Correctitud}

El algoritmo incluye en la solución el curso que termina primero, descarta los cursos que se solapan con este y repite lo anterior con los cursos restantes hasta que no queden más cursos.

Para que el procedimiento anterior arroje una solución válida, tiene que cumplirse que para cualquier instancia del problema, el curso con fecha de finalización más temprana siempre sea parte de alguna solución. Si esto se cumple, podemos incluir dicho curso en nuestra solución, descartar todos los cursos que se solapan con este, resolver el subproblema resultante aplicando el mismo razonamiento e incluir la solución del subproblema en la solución al problema original.

El teorema a continuación muestra que la suposición anterior es de hecho cierta.

\newtheorem*{teorema-ej2}{Teorema}

\begin{teorema-ej2}
    Sea $C = \{ (i_1, f_1), \ldots, (i_n, f_n) \}$ la oferta de $n$ cursos ordenados por fecha de finalización de forma creciente. Entonces el curso $(i_1, f_1)$ está incluido en algún subconjunto de $C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima.
\end{teorema-ej2}

\begin{proof}
    Sea $S$ algún subconjunto $\subseteq C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima, y sea $(i_j, f_j)$ el curso $\in S$ con fecha de finalización más temprana.

    Si $(i_j, f_j) = (i_1, f_1)$ terminamos la demostración, pues hemos mostrado que $(i_1, f_1)$ está incluido en algún subconjunto de $C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima.

    Si $(i_j, f_j) \neq (i_1, f_1)$, entonces sea $S' = S - \{ (i_j, f_j) \} \cup \{ (i_1, f_1) \}$ el conjunto $S$ al que le reemplazamos $(i_j, f_j)$ por $(i_1, f_1)$. Los cursos en $S'$ no se solapan entre sí pues:

    \begin{itemize}[nolistsep]
        \item{los cursos en $S$ no se solapan entre sí,}
        \item{$(i_j, f_j)$ es la actividad en $S$ que termina primero, y}
        \item{$f_1 \leq f_j$.}
    \end{itemize}

    Como $|S'| = |S|$, concluímos que $S'$ es un subconjunto de $C$ tal que sus cursos no se solapan entre sí y su cardinalidad es máxima, y $(i_1, f_1)$ está incluido en $S'$, como queríamos ver.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 3: Una noche en el museo                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Problema 3: Una noche en el museo}
Dada una grilla de n x m casillas, se nos pide ubicar una serie de sensores, los cuales deben poder sensar la totalidad de las casillas, obteniendo un gasto mínimo a la hora de poner los sensores.

Existen dos tipos de sensores, bidireccionales (izquierda y derecha) y cuatridireccionales (izquierda, derecha, arriba y abajo), de \$4000 y \$6000 respectivamente y 3 tipos de casilla, vacía, importante y pared. Es necesario que las casillas importantes tengan un cruce de sensores de dos láseres.

Se pide realizar el algoritmo mediante la técnica de Backtracking.

Ejemplos:

\subsection{Solucion}
\subsection{Complejidad}
\subsection{Experimentos computacionales}
\subsubsection{Correctitud}
\subsubsection{Performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusiones                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusiones}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\begin{appendices}

\section{Código fuente para el problema 1}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Código fuente para el problema 2}

Pendiente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 3                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Código fuente para el problema 3}

Pendiente.


\end{appendices}

\end{document}